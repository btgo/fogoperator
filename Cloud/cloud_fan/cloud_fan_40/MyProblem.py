
# -*- coding: utf-8 -*-
import numpy as np
import geatpy as ea

class MyProblem(ea.Problem):  # 继承Problem父类
    def __init__(self):
        name = 'MyProblem'  # 初始化name（函数名称，可以随意设置）
        M = 1  # 初始化M（目标维数）
        maxormins = [1]  # 初始化 maxormins （目标最小最大化标记列表，1：最小化该目标；-1：最大化该目标）
        Dim = 92  # 初始化Dim（决策变量维数）
        varTypes = [1] * Dim  # 初始化varTypes（决策变量的类型，元素为0表示对应的变量是连续的；1表示是离散的）
        lb = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              ]  # 决策变量下界 ,前八个是op所在节点的位置
        # 中间八个是op所使用的broker的位置
        # 最后两个每个broker所在节点的位置
        ub = [17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
              17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
              17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
              17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
              17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
              11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
              11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
              11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
              11, 11, 11, 11, 11, 11, 11, 11, 11, 11
              ]   # 决策变量上界
        lbin = [1] * Dim  # 决策变量下边界（0表示不包含该变量的下边界，1表示包含）
        ubin = [1] * Dim  # 决策变量上边界（0表示不包含该变量的上边界，1表示包含）
        # 调用父类构造方法完成实例化
        ea.Problem.__init__(self, name, M, maxormins, Dim, varTypes, lb, ub, lbin, ubin)


        # 添加属性来存储链路
        self.link = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],

                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])



    def aimFunc(self, pop):
        # 目标函数
        x = pop.Phen.astype(int)  # 得到决策变量矩阵
        #print(" pop.Phen ", pop.Phen)

        node_limit = []
        for i in range(0, len(x)):  # 各节点资源的限制
            node_limit.append([60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,

                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               60, 60, 20000, 40,
                               ])
        # print("node_limit", node_limit)
        X = np.hstack([x, node_limit]).astype(int)
        # print("X", X)

        Objv = []
        for i in range(X.shape[0]):  # 遍历每一个种群
            sum = 0
            for j in range(0, 40):  # 把每个节点上operator的资源消耗除去
                sub = 0
                pub = 0
                pub1 = 0
                sub1 = 0
                flag = 0
                for k in range(0, 40):
                    a = int(self.link[j][k])  # j->k判断是否有连接
                    b = int(self.link[k][j])  # k->j判断是否有连接
                    if a > 0:
                        if X[i][j] == X[i][k] & X[i][j] == X[i][X[i][j + 52] + 40]:  # 判断是否为节点内部传输
                            pub1 = pub1
                        else:
                            pub1 += 1
                        if X[i][j] != X[i][k] & X[i][j] != X[i][X[i][j + 52] + 40]:
                            flag += 1

                        pub += 1
                    if b > 0:
                        if X[i][j] == X[i][k] & X[i][j] == X[i][X[i][k + 52] + 40]:
                            sub1 = sub1
                        else:
                            sub1 += 1
                        sub += 1
                c = int(X[i][j])  # operator j所在的节点编号
                d = int(X[i][X[i][j + 52] + 40])  # op j所在的broker所在的节点编号
                X[i][c * 4 + 92] -= pub1  # 节点c 的pub消耗
                X[i][c * 4 + 93] -= sub1  # 节点c 的sub消耗
                X[i][c * 4 + 94] -= 1000  # 节点c 的cpu消耗
                X[i][c * 4 + 95] -= 1  # 节点c 的内存消耗
                if c == d:  # 若op j所在的节点和op j发送的broker所在的节点相同，broker的消耗
                    X[i][c * 4 + 94] -= 300 * pub  # 节点c 的cpu消耗
                    X[i][c * 4 + 95] -= 0.5 * pub  # 节点c 的内存消耗
                else:  # 若op j所在的节点和op j发送的broker所在的节点不同，broker的消耗
                    X[i][d * 4 + 94] -= 300 * pub  # 节点d 的cpu消耗
                    X[i][d * 4 + 95] -= 0.5 * pub  # 节点d 的内存消耗
                    X[i][d * 4 + 93] -= flag  # 节点d 的sub消耗
                    X[i][d * 4 + 92] -= flag  # 节点d 的pub消耗

            for j in range(0, 40):
                time_pub = 0
                time_sub = 0
                pub = 0
                sub = 0
                for k in range(0, 40):
                    a = int(self.link[j][k])  # j->k判断是否有连接
                    if a == 1:  # 节点 j->k有发出
                        if X[i][j] != X[i][X[i][j + 52] + 40]:
                            pub += 1
                        if X[i][k] != X[i][X[i][j + 52] + 40]:
                            sub += 1

                # print("pub", pub)
                # print("sub",sub)

                # op->broker传输消耗时间
                op_node = X[i][j]  # op j 所在的节点编号
                bro_node = X[i][X[i][j + 52] + 40]  # op j所在的broker所在的节点编号
                if op_node == bro_node:  # op与bro所在的节点相同
                    time_pub = 0
                else:
                    time_pub = pub * 40
                # elif (op_node == 0 & bro_node == 2) or (op_node == 2 & bro_node == 0):
                #     time_pub = pub * 30
                # elif (op_node == 0 & bro_node == 3) or (op_node == 3 & bro_node == 0):
                #     time_pub = pub * 50
                # elif (op_node == 1 & bro_node == 2) or (op_node == 2 & bro_node == 1):
                #     time_pub = pub * 25
                # elif (op_node == 1 & bro_node == 3) or (op_node == 3 & bro_node == 1):
                #     time_pub = pub * 20
                # elif (op_node == 3 & bro_node == 2) or (op_node == 2 & bro_node == 3):
                #     time_pub = pub * 20
                # broker->op传输消耗时间及broker处理时间
                # if bro_node == 0:  # bro在云端
                time_sub = sub * 40 + sub * 1
                # elif bro_node == 1:  # bro在雾端
                #     time_sub = sub1 * 30 + sub2 * 25 + sub3 * 20 + pub * 15
                # elif bro_node == 2:  # bro在雾端
                #     time_sub = sub1 * 30 + sub2 * 25 + sub3 * 20 + pub * 15
                # elif bro_node == 3:  # bro在边缘端
                #     time_sub = sub1 * 50 + sub2 * 20 + sub3 * 10 + pub * 30
                # print("time_sub",time_sub)
                # print("time_pub",time_pub)
                sum += time_sub + time_pub


                # print("sum",sum)
            # print(sum)
            Objv.append(sum)
            # print(X[i])
        pop.ObjV = np.array([Objv]).T  # 把求得的目标函数值赋值给种群pop的ObjV

        x1 = X[:, [92]]
        x2 = X[:, [93]]
        x3 = X[:, [94]]
        x4 = X[:, [95]]
        x5 = X[:, [96]]
        x6 = X[:, [97]]
        x7 = X[:, [98]]
        x8 = X[:, [99]]
        x9 = X[:, [100]]
        x10 = X[:, [101]]
        x11 = X[:, [102]]
        x12 = X[:, [103]]
        x13 = X[:, [104]]
        x14 = X[:, [105]]
        x15 = X[:, [106]]
        x16 = X[:, [107]]
        x21 = X[:, [108]]
        x22 = X[:, [109]]
        x23 = X[:, [110]]
        x24 = X[:, [111]]
        x25 = X[:, [112]]
        x26 = X[:, [113]]
        x27 = X[:, [114]]
        x28 = X[:, [115]]
        x29 = X[:, [116]]
        x30 = X[:, [117]]
        x31 = X[:, [118]]
        x32 = X[:, [119]]
        x33 = X[:, [120]]
        x34 = X[:, [121]]
        x35 = X[:, [122]]
        x36 = X[:, [123]]

        x41 = X[:, [124]]
        x42 = X[:, [125]]
        x43 = X[:, [126]]
        x44 = X[:, [127]]
        x45 = X[:, [128]]
        x46 = X[:, [129]]
        x47 = X[:, [130]]
        x48 = X[:, [131]]
        x49 = X[:, [132]]
        x50 = X[:, [133]]
        x51 = X[:, [134]]
        x52 = X[:, [135]]
        x53 = X[:, [136]]
        x54 = X[:, [137]]
        x55 = X[:, [138]]
        x56 = X[:, [139]]

        x61 = X[:, [140]]
        x62 = X[:, [141]]
        x63 = X[:, [142]]
        x64 = X[:, [143]]
        x65 = X[:, [144]]
        x66 = X[:, [145]]
        x67 = X[:, [146]]
        x68 = X[:, [147]]
        x69 = X[:, [148]]
        x70 = X[:, [149]]
        x71 = X[:, [150]]
        x72 = X[:, [151]]
        x73 = X[:, [152]]
        x74 = X[:, [153]]
        x75 = X[:, [154]]
        x76 = X[:, [155]]

        x77 = X[:, [156]]
        x78 = X[:, [157]]
        x79 = X[:, [157]]
        x80 = X[:, [159]]
        x81 = X[:, [160]]
        x82 = X[:, [161]]
        x83 = X[:, [162]]
        x84 = X[:, [163]]
        # 采用可行性法则处理约束

        exIdx1 = np.where(x1 < 0)[0]
        exIdx2 = np.where(x2 < 0)[0]
        exIdx3 = np.where(x3 < 0)[0]
        exIdx4 = np.where(x4 < 0)[0]
        exIdx5 = np.where(x5 < 0)[0]
        exIdx6 = np.where(x6 < 0)[0]
        exIdx7 = np.where(x7 < 0)[0]
        exIdx8 = np.where(x8 < 0)[0]
        exIdx9 = np.where(x9 < 0)[0]
        exIdx10 = np.where(x10 < 0)[0]
        exIdx11 = np.where(x11 < 0)[0]
        exIdx12 = np.where(x12 < 0)[0]
        exIdx13 = np.where(x13 < 0)[0]
        exIdx14 = np.where(x14 < 0)[0]
        exIdx15 = np.where(x15 < 0)[0]
        exIdx16 = np.where(x16 < 0)[0]
        exIdx21 = np.where(x21 < 0)[0]
        exIdx22 = np.where(x22 < 0)[0]
        exIdx23 = np.where(x23 < 0)[0]
        exIdx24 = np.where(x24 < 0)[0]
        exIdx25 = np.where(x25 < 0)[0]
        exIdx26 = np.where(x26 < 0)[0]
        exIdx27 = np.where(x27 < 0)[0]
        exIdx28 = np.where(x28 < 0)[0]
        exIdx29 = np.where(x29 < 0)[0]
        exIdx30 = np.where(x30 < 0)[0]
        exIdx31 = np.where(x31 < 0)[0]
        exIdx32 = np.where(x32 < 0)[0]
        exIdx33 = np.where(x33 < 0)[0]
        exIdx34 = np.where(x34 < 0)[0]
        exIdx35 = np.where(x35 < 0)[0]
        exIdx36 = np.where(x36 < 0)[0]

        exIdx41 = np.where(x41 < 0)[0]
        exIdx42 = np.where(x42 < 0)[0]
        exIdx43 = np.where(x43 < 0)[0]
        exIdx44 = np.where(x44 < 0)[0]
        exIdx45 = np.where(x45 < 0)[0]
        exIdx46 = np.where(x46 < 0)[0]
        exIdx47 = np.where(x47 < 0)[0]
        exIdx48 = np.where(x48 < 0)[0]
        exIdx49 = np.where(x49 < 0)[0]
        exIdx50 = np.where(x50 < 0)[0]
        exIdx51 = np.where(x51 < 0)[0]
        exIdx52 = np.where(x52 < 0)[0]
        exIdx53 = np.where(x53 < 0)[0]
        exIdx54 = np.where(x54 < 0)[0]
        exIdx55 = np.where(x55 < 0)[0]
        exIdx56 = np.where(x56 < 0)[0]
        exIdx61 = np.where(x61 < 0)[0]
        exIdx62 = np.where(x62 < 0)[0]
        exIdx63 = np.where(x63 < 0)[0]
        exIdx64 = np.where(x64 < 0)[0]
        exIdx65 = np.where(x65 < 0)[0]
        exIdx66 = np.where(x66 < 0)[0]
        exIdx67 = np.where(x67 < 0)[0]
        exIdx68 = np.where(x68 < 0)[0]
        exIdx69 = np.where(x69 < 0)[0]
        exIdx70 = np.where(x70 < 0)[0]
        exIdx71 = np.where(x71 < 0)[0]
        exIdx72 = np.where(x72 < 0)[0]
        exIdx73 = np.where(x73 < 0)[0]
        exIdx74 = np.where(x74 < 0)[0]
        exIdx75 = np.where(x75 < 0)[0]
        exIdx76 = np.where(x76 < 0)[0]
        exIdx77 = np.where(x77 < 0)[0]
        exIdx78 = np.where(x78 < 0)[0]
        exIdx79 = np.where(x79 < 0)[0]
        exIdx80 = np.where(x80 < 0)[0]
        exIdx81 = np.where(x81 < 0)[0]
        exIdx82 = np.where(x82 < 0)[0]
        exIdx83 = np.where(x83 < 0)[0]
        exIdx84 = np.where(x84 < 0)[0]






        exIdx = np.unique(np.hstack([exIdx1, exIdx2, exIdx3, exIdx4, exIdx5, exIdx6, exIdx7, exIdx8, exIdx9, exIdx10,
                                     exIdx11, exIdx12, exIdx13, exIdx14, exIdx15, exIdx16,
                                     exIdx21, exIdx22, exIdx23, exIdx24, exIdx25, exIdx26, exIdx27, exIdx28, exIdx29,
                                     exIdx30,
                                     exIdx31, exIdx32, exIdx33, exIdx34, exIdx35, exIdx36,
                                     exIdx41, exIdx42, exIdx43, exIdx44, exIdx45, exIdx46, exIdx47, exIdx48, exIdx49,
                                     exIdx50,
                                     exIdx51, exIdx52, exIdx53, exIdx54, exIdx55, exIdx56,
                                     exIdx61, exIdx62, exIdx63, exIdx64, exIdx65, exIdx66, exIdx67, exIdx68, exIdx69,
                                     exIdx70, exIdx71, exIdx72, exIdx73, exIdx74, exIdx75, exIdx76,exIdx77,
                                     exIdx78, exIdx79, exIdx80, exIdx81, exIdx82, exIdx83, exIdx84
                                     ]))
        pop.CV = np.zeros((pop.sizes, 1))
        pop.CV[exIdx] = 1  # 把求得的违反约束程度矩阵赋值给种群pop的CV
        # pop.CV = np.hstack([x1,
        #                     x2,
        #                     x3,
        #                     x4,
        #                     x5,
        #                     x6,
        #                     x7,
        #                     x8,
        #                     x9,
        #                     x10,
        #                     x11,
        #                     x12,
        #                     x13,
        #                     x14,
        #                     x15,
        #                     x16])
        #
        # print('pop.CV')
        # print(pop.CV)
